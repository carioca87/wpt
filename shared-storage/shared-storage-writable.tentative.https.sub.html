<!doctype html>
<body>
  <script src=/resources/testharness.js></script>
  <script src=/resources/testharnessreport.js></script>
  <script src=/common/utils.js></script>
  <script src=/common/get-host-info.sub.js></script>
  <script src=/shared-storage/resources/util.js></script>
  <script src=/fenced-frame/resources/utils.js></script>
  <script>
    'use strict';

    const rawSetterHeader = 'set;key=hello;value=world;ignore_if_present,'
      + 'append;value=friend;key=hello';
    const setterHeader = encodeURIComponent(rawSetterHeader);
    const rawDeleteHeader = 'delete;key=hello';
    const deleteHeader = encodeURIComponent(rawDeleteHeader);

    const sameOriginSetterUrl =
      `/shared-storage/resources/shared-storage-write.py?write=${setterHeader}`;
    const sameOriginDeleteUrl =
      `/shared-storage/resources/shared-storage-write.py?write=${deleteHeader}`;
   const sameOriginClearUrl =
      `/shared-storage/resources/shared-storage-write.py?write=clear`;

    const crossOrigin = 'https://{{domains[www]}}:{{ports[https][0]}}';
    const crossOriginSetterUrl = crossOrigin + sameOriginSetterUrl;
    const crossOriginDeleteUrl = crossOrigin + sameOriginDeleteUrl;
    const crossOriginClearUrl = crossOrigin + sameOriginClearUrl;

    promise_test(async t => {
      let response = await fetch(sameOriginSetterUrl,
                                 {sharedStorageWritable: true});
      let sharedStorageWritableHeader = await response.text();
      assert_equals(sharedStorageWritableHeader, "?1");

      const ancestorKey = token();
      let url0 = generateURL("/shared-storage/resources/frame0.html",
                             [ancestorKey]);
      let url1 = generateURL("/shared-storage/resources/frame1.html",
                             [ancestorKey]);
      await addModuleOnce('/shared-storage/resources/simple-module.js');

      let fencedFrameConfig = await sharedStorage.selectURL(
        "verify-key-value", [{url: url0}, {url: url1}],
        {data: {'expectedKey': 'hello', 'expectedValue': 'worldfriend'},
         resolveToConfig: true, keepAlive: true});
      assert_true(validateSelectURLResult(fencedFrameConfig, true));

      attachFencedFrame(fencedFrameConfig, 'opaque-ads');
      const result = await nextValueFromServer(ancestorKey);
      assert_equals(result, "frame1_loaded");
    }, 'Writing to shared storage via the \'Shared-Storage-Write\' header '
       + 'for a same-origin shared storage fetch request');

    promise_test(async t => {
      let response = await fetch(crossOriginSetterUrl,
                                 {sharedStorageWritable: true});
      let sharedStorageWritableHeader = await response.text();
      assert_equals(sharedStorageWritableHeader, "?1");

      const outerKey = token();
      const innerKey = token();
      let iframeUrl = generateURL(
        "/shared-storage/resources/verify-key-value.https.html",
        [outerKey, innerKey]);
      iframeUrl = updateUrlToUseNewOrigin(iframeUrl, crossOrigin);
      appendExpectedKeyAndValue(iframeUrl, 'hello', 'worldfriend');

      attachIFrame(iframeUrl);
      const result = await nextValueFromServer(outerKey);
      assert_equals(result, "verify_key_value_loaded");
    }, 'Writing to shared storage via the \'Shared-Storage-Write\' header '
       + 'for a cross-origin shared storage fetch request');

    promise_test(async t => {
      await sharedStorage.set("hello", "there");

      const ancestorKey = token();
      let url0 = generateURL("/shared-storage/resources/frame0.html",
                             [ancestorKey]);
      let url1 = generateURL("/shared-storage/resources/frame1.html",
                             [ancestorKey]);
      await addModuleOnce('/shared-storage/resources/simple-module.js');

      let fencedFrameConfig0 = await sharedStorage.selectURL(
        "verify-key-value", [{url: url0}, {url: url1}],
         {data: {'expectedKey': 'hello', 'expectedValue': 'there'},
         resolveToConfig: true, keepAlive: true});
      assert_true(validateSelectURLResult(fencedFrameConfig0, true));

      attachFencedFrame(fencedFrameConfig0, 'opaque-ads');
      const result0 = await nextValueFromServer(ancestorKey);
      assert_equals(result0, "frame1_loaded");

      let response = await fetch(sameOriginDeleteUrl,
                                 {sharedStorageWritable: true});
      let sharedStorageWritableHeader = await response.text();
      assert_equals(sharedStorageWritableHeader, "?1");

      let fencedFrameConfig1 = await sharedStorage.selectURL(
        "verify-key-not-found", [{url: url0}, {url: url1}],
        {data: {'expectedKey': 'hello'},
         resolveToConfig: true, keepAlive: true});
      assert_true(validateSelectURLResult(fencedFrameConfig1, true));

      attachFencedFrame(fencedFrameConfig1, 'opaque-ads');
      const result1 = await nextValueFromServer(ancestorKey);
      assert_equals(result1, "frame1_loaded");
    }, 'Deleting from shared storage via the \'Shared-Storage-Write\' header '
       + 'for a same-origin shared storage fetch request');

    promise_test(async t => {
      const outerKey = token();
      const innerKey = token();
      let setIframeUrl = generateURL(
        "/shared-storage/resources/set-key-value.https.html", [outerKey]);
      setIframeUrl = updateUrlToUseNewOrigin(setIframeUrl, crossOrigin);
      appendExpectedKeyAndValue(setIframeUrl, 'hello', 'there');

      attachIFrame(setIframeUrl);
      const result0 = await nextValueFromServer(outerKey);
      assert_equals(result0, "set_key_value_loaded");

      let verifyFoundIframeUrl = generateURL(
        "/shared-storage/resources/verify-key-value.https.html",
        [outerKey, innerKey]);
      verifyFoundIframeUrl = updateUrlToUseNewOrigin(verifyFoundIframeUrl,
        crossOrigin);
      appendExpectedKeyAndValue(verifyFoundIframeUrl, 'hello', 'there');

      attachIFrame(verifyFoundIframeUrl);
      const result1 = await nextValueFromServer(outerKey);
      assert_equals(result1, "verify_key_value_loaded");

      let response = await fetch(crossOriginDeleteUrl,
                                 {sharedStorageWritable: true});
      let sharedStorageWritableHeader = await response.text();
      assert_equals(sharedStorageWritableHeader, "?1");

      let verifyNotFoundIframeUrl = generateURL(
        "/shared-storage/resources/verify-key-not-found.https.html",
        [outerKey, innerKey]);
      verifyNotFoundIframeUrl = updateUrlToUseNewOrigin(
        verifyNotFoundIframeUrl, crossOrigin);
      appendExpectedKey(verifyNotFoundIframeUrl, 'hello');

      attachIFrame(verifyNotFoundIframeUrl);
      const result2 = await nextValueFromServer(outerKey);
      assert_equals(result2, "verify_key_not_found_loaded");
    }, 'Deleting from shared storage via the \'Shared-Storage-Write\' header '
       + 'for a cross-origin shared storage fetch request');

    promise_test(async t => {
      await sharedStorage.set("hello", "there");

      const ancestorKey = token();
      let url0 = generateURL("/shared-storage/resources/frame0.html",
                             [ancestorKey]);
      let url1 = generateURL("/shared-storage/resources/frame1.html",
                             [ancestorKey]);
      await addModuleOnce('/shared-storage/resources/simple-module.js');

      let fencedFrameConfig0 = await sharedStorage.selectURL(
        "verify-key-value", [{url: url0}, {url: url1}],
         {data: {'expectedKey': 'hello', 'expectedValue': 'there'},
         resolveToConfig: true, keepAlive: true});
      assert_true(validateSelectURLResult(fencedFrameConfig0, true));

      attachFencedFrame(fencedFrameConfig0, 'opaque-ads');
      const result0 = await nextValueFromServer(ancestorKey);
      assert_equals(result0, "frame1_loaded");

      let response = await fetch(sameOriginClearUrl,
                                 {sharedStorageWritable: true});
      let sharedStorageWritableHeader = await response.text();
      assert_equals(sharedStorageWritableHeader, "?1");

      let fencedFrameConfig1 = await sharedStorage.selectURL(
        "verify-key-not-found", [{url: url0}, {url: url1}],
        {data: {'expectedKey': 'hello'},
         resolveToConfig: true, keepAlive: true});
      assert_true(validateSelectURLResult(fencedFrameConfig1, true));

      attachFencedFrame(fencedFrameConfig1, 'opaque-ads');
      const result1 = await nextValueFromServer(ancestorKey);
      assert_equals(result1, "frame1_loaded");
    }, 'Clearing from shared storage via the \'Shared-Storage-Write\' header '
       + 'for a same-origin shared storage fetch request');

    promise_test(async t => {
      const outerKey = token();
      const innerKey = token();
      let setIframeUrl = generateURL(
        "/shared-storage/resources/set-key-value.https.html", [outerKey]);
      setIframeUrl = updateUrlToUseNewOrigin(setIframeUrl, crossOrigin);
      appendExpectedKeyAndValue(setIframeUrl, 'hello', 'there');

      attachIFrame(setIframeUrl);
      const result0 = await nextValueFromServer(outerKey);
      assert_equals(result0, "set_key_value_loaded");

      let verifyFoundIframeUrl = generateURL(
        "/shared-storage/resources/verify-key-value.https.html",
        [outerKey, innerKey]);
      verifyFoundIframeUrl = updateUrlToUseNewOrigin(verifyFoundIframeUrl,
        crossOrigin);
      appendExpectedKeyAndValue(verifyFoundIframeUrl, 'hello', 'there');

      attachIFrame(verifyFoundIframeUrl);
      const result1 = await nextValueFromServer(outerKey);
      assert_equals(result1, "verify_key_value_loaded");

      let response = await fetch(crossOriginClearUrl,
                                 {sharedStorageWritable: true});
      let sharedStorageWritableHeader = await response.text();
      assert_equals(sharedStorageWritableHeader, "?1");

      let verifyNotFoundIframeUrl = generateURL(
        "/shared-storage/resources/verify-key-not-found.https.html",
        [outerKey, innerKey]);
      verifyNotFoundIframeUrl = updateUrlToUseNewOrigin(
        verifyNotFoundIframeUrl, crossOrigin);
      appendExpectedKey(verifyNotFoundIframeUrl, 'hello');

      attachIFrame(verifyNotFoundIframeUrl);
      const result2 = await nextValueFromServer(outerKey);
      assert_equals(result2, "verify_key_not_found_loaded");
    }, 'Clearing from shared storage via the \'Shared-Storage-Write\' header '
       + 'for a cross-origin shared storage fetch request');
  </script>
</body>
